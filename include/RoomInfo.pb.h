// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RoomInfo.proto

#ifndef PROTOBUF_INCLUDED_RoomInfo_2eproto
#define PROTOBUF_INCLUDED_RoomInfo_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_RoomInfo_2eproto 

namespace protobuf_RoomInfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_RoomInfo_2eproto
namespace RoomInfo {
class RoomInfoPackage;
class RoomInfoPackageDefaultTypeInternal;
extern RoomInfoPackageDefaultTypeInternal _RoomInfoPackage_default_instance_;
class RoomInformation;
class RoomInformationDefaultTypeInternal;
extern RoomInformationDefaultTypeInternal _RoomInformation_default_instance_;
}  // namespace RoomInfo
namespace google {
namespace protobuf {
template<> ::RoomInfo::RoomInfoPackage* Arena::CreateMaybeMessage<::RoomInfo::RoomInfoPackage>(Arena*);
template<> ::RoomInfo::RoomInformation* Arena::CreateMaybeMessage<::RoomInfo::RoomInformation>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace RoomInfo {

// ===================================================================

class RoomInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomInfo.RoomInformation) */ {
 public:
  RoomInformation();
  virtual ~RoomInformation();

  RoomInformation(const RoomInformation& from);

  inline RoomInformation& operator=(const RoomInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomInformation(RoomInformation&& from) noexcept
    : RoomInformation() {
    *this = ::std::move(from);
  }

  inline RoomInformation& operator=(RoomInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomInformation* internal_default_instance() {
    return reinterpret_cast<const RoomInformation*>(
               &_RoomInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RoomInformation* other);
  friend void swap(RoomInformation& a, RoomInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomInformation* New() const final {
    return CreateMaybeMessage<RoomInformation>(NULL);
  }

  RoomInformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomInformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomInformation& from);
  void MergeFrom(const RoomInformation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 colors = 6;
  int colors_size() const;
  void clear_colors();
  static const int kColorsFieldNumber = 6;
  ::google::protobuf::int32 colors(int index) const;
  void set_colors(int index, ::google::protobuf::int32 value);
  void add_colors(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      colors() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_colors();

  // repeated string players = 7;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 7;
  const ::std::string& players(int index) const;
  ::std::string* mutable_players(int index);
  void set_players(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_players(int index, ::std::string&& value);
  #endif
  void set_players(int index, const char* value);
  void set_players(int index, const char* value, size_t size);
  ::std::string* add_players();
  void add_players(const ::std::string& value);
  #if LANG_CXX11
  void add_players(::std::string&& value);
  #endif
  void add_players(const char* value);
  void add_players(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& players() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_players();

  // repeated int32 types = 8;
  int types_size() const;
  void clear_types();
  static const int kTypesFieldNumber = 8;
  ::google::protobuf::int32 types(int index) const;
  void set_types(int index, ::google::protobuf::int32 value);
  void add_types(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      types() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_types();

  // repeated bool ready = 9;
  int ready_size() const;
  void clear_ready();
  static const int kReadyFieldNumber = 9;
  bool ready(int index) const;
  void set_ready(int index, bool value);
  void add_ready(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      ready() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_ready();

  // required string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // required string map = 2;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 2;
  const ::std::string& map() const;
  void set_map(const ::std::string& value);
  #if LANG_CXX11
  void set_map(::std::string&& value);
  #endif
  void set_map(const char* value);
  void set_map(const char* value, size_t size);
  ::std::string* mutable_map();
  ::std::string* release_map();
  void set_allocated_map(::std::string* map);

  // required int32 capacity = 3;
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  ::google::protobuf::int32 capacity() const;
  void set_capacity(::google::protobuf::int32 value);

  // required int32 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // required bool active = 5;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 5;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:RoomInfo.RoomInformation)
 private:
  void set_has_host();
  void clear_has_host();
  void set_has_map();
  void clear_has_map();
  void set_has_capacity();
  void clear_has_capacity();
  void set_has_size();
  void clear_has_size();
  void set_has_active();
  void clear_has_active();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > colors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> players_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > types_;
  ::google::protobuf::RepeatedField< bool > ready_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr map_;
  ::google::protobuf::int32 capacity_;
  ::google::protobuf::int32 size_;
  bool active_;
  friend struct ::protobuf_RoomInfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomInfoPackage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomInfo.RoomInfoPackage) */ {
 public:
  RoomInfoPackage();
  virtual ~RoomInfoPackage();

  RoomInfoPackage(const RoomInfoPackage& from);

  inline RoomInfoPackage& operator=(const RoomInfoPackage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomInfoPackage(RoomInfoPackage&& from) noexcept
    : RoomInfoPackage() {
    *this = ::std::move(from);
  }

  inline RoomInfoPackage& operator=(RoomInfoPackage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfoPackage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomInfoPackage* internal_default_instance() {
    return reinterpret_cast<const RoomInfoPackage*>(
               &_RoomInfoPackage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RoomInfoPackage* other);
  friend void swap(RoomInfoPackage& a, RoomInfoPackage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomInfoPackage* New() const final {
    return CreateMaybeMessage<RoomInfoPackage>(NULL);
  }

  RoomInfoPackage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomInfoPackage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomInfoPackage& from);
  void MergeFrom(const RoomInfoPackage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfoPackage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RoomInfo.RoomInformation roominfo = 1;
  int roominfo_size() const;
  void clear_roominfo();
  static const int kRoominfoFieldNumber = 1;
  ::RoomInfo::RoomInformation* mutable_roominfo(int index);
  ::google::protobuf::RepeatedPtrField< ::RoomInfo::RoomInformation >*
      mutable_roominfo();
  const ::RoomInfo::RoomInformation& roominfo(int index) const;
  ::RoomInfo::RoomInformation* add_roominfo();
  const ::google::protobuf::RepeatedPtrField< ::RoomInfo::RoomInformation >&
      roominfo() const;

  // @@protoc_insertion_point(class_scope:RoomInfo.RoomInfoPackage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RoomInfo::RoomInformation > roominfo_;
  friend struct ::protobuf_RoomInfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoomInformation

// required string host = 1;
inline bool RoomInformation::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInformation::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInformation::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInformation::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& RoomInformation::host() const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.host)
  return host_.GetNoArena();
}
inline void RoomInformation::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.host)
}
#if LANG_CXX11
inline void RoomInformation::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RoomInfo.RoomInformation.host)
}
#endif
inline void RoomInformation::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomInfo.RoomInformation.host)
}
inline void RoomInformation::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomInfo.RoomInformation.host)
}
inline ::std::string* RoomInformation::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:RoomInfo.RoomInformation.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInformation::release_host() {
  // @@protoc_insertion_point(field_release:RoomInfo.RoomInformation.host)
  if (!has_host()) {
    return NULL;
  }
  clear_has_host();
  return host_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInformation::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:RoomInfo.RoomInformation.host)
}

// required string map = 2;
inline bool RoomInformation::has_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInformation::set_has_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInformation::clear_has_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInformation::clear_map() {
  map_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map();
}
inline const ::std::string& RoomInformation::map() const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.map)
  return map_.GetNoArena();
}
inline void RoomInformation::set_map(const ::std::string& value) {
  set_has_map();
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.map)
}
#if LANG_CXX11
inline void RoomInformation::set_map(::std::string&& value) {
  set_has_map();
  map_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RoomInfo.RoomInformation.map)
}
#endif
inline void RoomInformation::set_map(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map();
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomInfo.RoomInformation.map)
}
inline void RoomInformation::set_map(const char* value, size_t size) {
  set_has_map();
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomInfo.RoomInformation.map)
}
inline ::std::string* RoomInformation::mutable_map() {
  set_has_map();
  // @@protoc_insertion_point(field_mutable:RoomInfo.RoomInformation.map)
  return map_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInformation::release_map() {
  // @@protoc_insertion_point(field_release:RoomInfo.RoomInformation.map)
  if (!has_map()) {
    return NULL;
  }
  clear_has_map();
  return map_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInformation::set_allocated_map(::std::string* map) {
  if (map != NULL) {
    set_has_map();
  } else {
    clear_has_map();
  }
  map_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map);
  // @@protoc_insertion_point(field_set_allocated:RoomInfo.RoomInformation.map)
}

// required int32 capacity = 3;
inline bool RoomInformation::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInformation::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInformation::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInformation::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline ::google::protobuf::int32 RoomInformation::capacity() const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.capacity)
  return capacity_;
}
inline void RoomInformation::set_capacity(::google::protobuf::int32 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.capacity)
}

// required int32 size = 4;
inline bool RoomInformation::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomInformation::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomInformation::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomInformation::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 RoomInformation::size() const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.size)
  return size_;
}
inline void RoomInformation::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.size)
}

// required bool active = 5;
inline bool RoomInformation::has_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInformation::set_has_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInformation::clear_has_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInformation::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool RoomInformation::active() const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.active)
  return active_;
}
inline void RoomInformation::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.active)
}

// repeated int32 colors = 6;
inline int RoomInformation::colors_size() const {
  return colors_.size();
}
inline void RoomInformation::clear_colors() {
  colors_.Clear();
}
inline ::google::protobuf::int32 RoomInformation::colors(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.colors)
  return colors_.Get(index);
}
inline void RoomInformation::set_colors(int index, ::google::protobuf::int32 value) {
  colors_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.colors)
}
inline void RoomInformation::add_colors(::google::protobuf::int32 value) {
  colors_.Add(value);
  // @@protoc_insertion_point(field_add:RoomInfo.RoomInformation.colors)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RoomInformation::colors() const {
  // @@protoc_insertion_point(field_list:RoomInfo.RoomInformation.colors)
  return colors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RoomInformation::mutable_colors() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.RoomInformation.colors)
  return &colors_;
}

// repeated string players = 7;
inline int RoomInformation::players_size() const {
  return players_.size();
}
inline void RoomInformation::clear_players() {
  players_.Clear();
}
inline const ::std::string& RoomInformation::players(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.players)
  return players_.Get(index);
}
inline ::std::string* RoomInformation::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:RoomInfo.RoomInformation.players)
  return players_.Mutable(index);
}
inline void RoomInformation::set_players(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.players)
  players_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoomInformation::set_players(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.players)
  players_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoomInformation::set_players(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  players_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RoomInfo.RoomInformation.players)
}
inline void RoomInformation::set_players(int index, const char* value, size_t size) {
  players_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RoomInfo.RoomInformation.players)
}
inline ::std::string* RoomInformation::add_players() {
  // @@protoc_insertion_point(field_add_mutable:RoomInfo.RoomInformation.players)
  return players_.Add();
}
inline void RoomInformation::add_players(const ::std::string& value) {
  players_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RoomInfo.RoomInformation.players)
}
#if LANG_CXX11
inline void RoomInformation::add_players(::std::string&& value) {
  players_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RoomInfo.RoomInformation.players)
}
#endif
inline void RoomInformation::add_players(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  players_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RoomInfo.RoomInformation.players)
}
inline void RoomInformation::add_players(const char* value, size_t size) {
  players_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RoomInfo.RoomInformation.players)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoomInformation::players() const {
  // @@protoc_insertion_point(field_list:RoomInfo.RoomInformation.players)
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoomInformation::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.RoomInformation.players)
  return &players_;
}

// repeated int32 types = 8;
inline int RoomInformation::types_size() const {
  return types_.size();
}
inline void RoomInformation::clear_types() {
  types_.Clear();
}
inline ::google::protobuf::int32 RoomInformation::types(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.types)
  return types_.Get(index);
}
inline void RoomInformation::set_types(int index, ::google::protobuf::int32 value) {
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.types)
}
inline void RoomInformation::add_types(::google::protobuf::int32 value) {
  types_.Add(value);
  // @@protoc_insertion_point(field_add:RoomInfo.RoomInformation.types)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RoomInformation::types() const {
  // @@protoc_insertion_point(field_list:RoomInfo.RoomInformation.types)
  return types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RoomInformation::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.RoomInformation.types)
  return &types_;
}

// repeated bool ready = 9;
inline int RoomInformation::ready_size() const {
  return ready_.size();
}
inline void RoomInformation::clear_ready() {
  ready_.Clear();
}
inline bool RoomInformation::ready(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInformation.ready)
  return ready_.Get(index);
}
inline void RoomInformation::set_ready(int index, bool value) {
  ready_.Set(index, value);
  // @@protoc_insertion_point(field_set:RoomInfo.RoomInformation.ready)
}
inline void RoomInformation::add_ready(bool value) {
  ready_.Add(value);
  // @@protoc_insertion_point(field_add:RoomInfo.RoomInformation.ready)
}
inline const ::google::protobuf::RepeatedField< bool >&
RoomInformation::ready() const {
  // @@protoc_insertion_point(field_list:RoomInfo.RoomInformation.ready)
  return ready_;
}
inline ::google::protobuf::RepeatedField< bool >*
RoomInformation::mutable_ready() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.RoomInformation.ready)
  return &ready_;
}

// -------------------------------------------------------------------

// RoomInfoPackage

// repeated .RoomInfo.RoomInformation roominfo = 1;
inline int RoomInfoPackage::roominfo_size() const {
  return roominfo_.size();
}
inline void RoomInfoPackage::clear_roominfo() {
  roominfo_.Clear();
}
inline ::RoomInfo::RoomInformation* RoomInfoPackage::mutable_roominfo(int index) {
  // @@protoc_insertion_point(field_mutable:RoomInfo.RoomInfoPackage.roominfo)
  return roominfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::RoomInfo::RoomInformation >*
RoomInfoPackage::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable_list:RoomInfo.RoomInfoPackage.roominfo)
  return &roominfo_;
}
inline const ::RoomInfo::RoomInformation& RoomInfoPackage::roominfo(int index) const {
  // @@protoc_insertion_point(field_get:RoomInfo.RoomInfoPackage.roominfo)
  return roominfo_.Get(index);
}
inline ::RoomInfo::RoomInformation* RoomInfoPackage::add_roominfo() {
  // @@protoc_insertion_point(field_add:RoomInfo.RoomInfoPackage.roominfo)
  return roominfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RoomInfo::RoomInformation >&
RoomInfoPackage::roominfo() const {
  // @@protoc_insertion_point(field_list:RoomInfo.RoomInfoPackage.roominfo)
  return roominfo_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoomInfo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_RoomInfo_2eproto
